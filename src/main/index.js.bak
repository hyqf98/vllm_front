import { app, shell, BrowserWindow, ipcMain } from 'electron'
import { join } from 'path'
import { electronApp, optimizer, is } from '@electron-toolkit/utils'
import icon from '../../resources/icon.png?asset'
import sshManager from './ssh-manager'
import dataManager from './data-manager'
import modelTestHandler from './model-test-handler'

function createWindow() {
  // 获取主显示器的完整尺寸
  const { screen } = require('electron')
  const primaryDisplay = screen.getPrimaryDisplay()
  const { width, height } = primaryDisplay.bounds

  // 设置窗口大小为显示器的一半
  const windowWidth = Math.floor(width / 2)
  const windowHeight = Math.floor(height / 2)

  // Create the browser window.
  const mainWindow = new BrowserWindow({
    width: 1920,
    height: 1080,
    show: false,
    autoHideMenuBar: true,
    ...(process.platform === 'linux' ? { icon } : {}),
    webPreferences: {
      preload: join(__dirname, '../preload/index.js'),
      sandbox: false,
      webSecurity: false,
      nodeIntegration: false,
      contextIsolation: true,
      webviewTag: true
    }
  })

  mainWindow.on('ready-to-show', () => {
    mainWindow.show()
  })

  mainWindow.webContents.setWindowOpenHandler((details) => {
    shell.openExternal(details.url)
    return { action: 'deny' }
  })

  // HMR for renderer base on electron-vite cli.
  // Load the remote URL for development or the local html file for production.
  if (is.dev && process.env['ELECTRON_RENDERER_URL']) {
    mainWindow.loadURL(process.env['ELECTRON_RENDERER_URL'])
  } else {
    mainWindow.loadFile(join(__dirname, '../renderer/index.html'))
  }
}

/**
 * 确保服务器已加载到 ssh-manager
 * @param {string} serverId - 服务器ID
 */
async function ensureServerLoaded(serverId) {
  // 先检查是否已经在 ssh-manager 中
  const existingServer = sshManager.getServerById(serverId)
  if (existingServer) {
    return existingServer
  }

  // 从数据存储中读取服务器信息
  const servers = await dataManager.readData('servers', [])

  if (Array.isArray(servers) && servers.length > 0) {
    const server = servers.find(s => s.id === serverId)
    if (server) {
      sshManager.addServer(server)

      // 尝试建立连接（如果尚未连接）
      const existingConn = sshManager.connections.get(serverId)
      if (!existingConn && server.type !== 'localhost') {
        try {
          await sshManager.connect({
            serverId: server.id,
            type: server.type || 'ssh',
            host: server.host,
            port: server.port,
            username: server.username,
            password: server.password,
            privateKey: server.privateKey
          })
        } catch (error) {
          console.error(`[ensureServerLoaded] 服务器 ${serverId} 连接失败:`, error.message)
          // 连接失败不抛出错误，继续执行（命令执行时会重试）
        }
      } else if (server.type === 'localhost') {
        // localhost 类型直接添加连接标记
        sshManager.connections.set(serverId, { type: 'localhost' })
      }

      return server
    }
  }

  console.error(`[ensureServerLoaded] 服务器 ${serverId} 不存在`)
  throw new Error(`服务器 ${serverId} 不存在`)
}

// app启动完成后设置对应的监听事件
app.whenReady().then(() => {
  // 为应用设置用户模型ID
  electronApp.setAppUserModelId('com.electron')

  // 默认打开或关闭DevTools
  app.on('browser-window-created', (_, window) => {
    optimizer.watchWindowShortcuts(window)
  })

  // 注册IPC处理器
  setupIPCHandlers()

  createWindow()

  app.on('activate', function () {
    // mac系统点击dock图标时创建窗口
    if (BrowserWindow.getAllWindows().length === 0) createWindow()
  })
})

// 监听所有的窗口关闭事件
app.on('window-all-closed', () => {
  // 断开所有SSH连接
  sshManager.disconnectAll()
  // mac系统的关闭
  if (process.platform !== 'darwin') {
    app.quit()
  }
})

/**
 * 设置IPC处理器
 */
function setupIPCHandlers() {
  // SSH连接管理
  ipcMain.handle('ssh:connect', async (event, config) => {
    try {
      const result = await sshManager.connect(config)
      return { success: true, data: result }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  ipcMain.handle('ssh:disconnect', async (event, serverId) => {
    try {
      await sshManager.disconnect(serverId)
      return { success: true }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  ipcMain.handle('ssh:execCommand', async (event, serverId, command) => {
    try {
      const result = await sshManager.execCommand(serverId, command)
      return {
        success: result.success,
        code: result.code,
        signal: result.signal,
        stdout: result.stdout,
        stderr: result.stderr
      }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 流式执行命令
  ipcMain.handle('ssh:execCommandStream', async (event, serverId, command, taskId) => {
    try {
      const mainWindow = BrowserWindow.fromWebContents(event.sender)

      sshManager.execCommandStream(
        serverId,
        command,
        (stdout, stderr) => {
          // onData: 发送流式数据
          if (mainWindow && mainWindow.webContents) {
            mainWindow.webContents.send('ssh:stream:data', {
              taskId,
              stdout,
              stderr
            })
          }
        },
        (code, signal) => {
          // onClose: 发送结束事件
          if (mainWindow && mainWindow.webContents) {
            mainWindow.webContents.send('ssh:stream:close', {
              taskId,
              code,
              signal
            })
          }
        }
      )

      return { success: true }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  ipcMain.handle('ssh:listDirectory', async (event, serverId, path) => {
    try {
      const result = await sshManager.listDirectory(serverId, path)
      return { success: true, data: result }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  ipcMain.handle('ssh:getServerInfo', async (event, serverId) => {
    try {
      const result = await sshManager.getServerInfo(serverId)
      return result
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 环境检查
  ipcMain.handle('ssh:checkEnvironment', async (event, serverId, envType, envName) => {
    try {
      const exists = await sshManager.checkEnvironment(serverId, envType, envName)
      return { success: true, exists }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 获取环境列表
  ipcMain.handle('ssh:getEnvironmentList', async (event, serverId, envType) => {
    try {
      const result = await sshManager.getEnvironmentList(serverId, envType)
      return result
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 检测服务器上所有环境
  ipcMain.handle('ssh:detectEnvironments', async (event, serverId) => {
    try {
      const result = await sshManager.detectEnvironments(serverId)
      return result
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 获取 conda 环境列表
  ipcMain.handle('ssh:getCondaEnvironments', async (event, serverId, condaPath) => {
    try {
      const result = await sshManager.getCondaEnvironments(serverId, condaPath)
      return result
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 获取服务器GPU列表
  ipcMain.handle('ssh:getServerGPUs', async (event, serverId) => {
    try {
      await ensureServerLoaded(serverId)
      const result = await sshManager.getServerGPUs(serverId)
      return result
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 服务管理
  ipcMain.handle('service:start', async (event, serverId, serviceConfig) => {
    try {
      const result = await sshManager.startService(serverId, serviceConfig)
      return { success: true, data: result }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  ipcMain.handle('service:stop', async (event, serverId, pid, startCommand) => {
    try {
      const result = await sshManager.stopService(serverId, pid, startCommand)
      return { success: true, data: result }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  ipcMain.handle('service:checkStatus', async (event, serverId, pid) => {
    try {
      const result = await sshManager.checkServiceStatus(serverId, pid)
      return { success: true, data: result }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 日志管理
  ipcMain.handle('log:read', async (event, serverId, logPath, lines) => {
    try {
      await ensureServerLoaded(serverId)
      const content = await sshManager.readLog(serverId, logPath, lines)
      return { success: true, content }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 框架升级
  ipcMain.handle('framework:upgrade', async (event, serverId, upgradeConfig) => {
    try {
      await ensureServerLoaded(serverId)
      const result = await sshManager.upgradeFramework(serverId, upgradeConfig)
      return { success: true, data: result }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  ipcMain.handle('framework:getVersion', async (event, serverId, framework, envType, envName) => {
    try {
      await ensureServerLoaded(serverId)
      const version = await sshManager.getFrameworkVersion(serverId, framework, envType, envName)
      return { success: true, version }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 批量检查服务状态
  ipcMain.handle('service:checkAllStatus', async (event, services) => {
    try {
      const results = []

      for (const service of services) {
        const { serverId, port, startCommand } = service

        // 先连接服务器
        const serverResult = await sshManager.connect({
          serverId,
          host: service.host,
          port: service.sshPort || 22,
          username: service.username,
          password: service.password,
          privateKey: service.privateKey
        })

        if (!serverResult.success) {
          results.push({
            serviceId: service.id,
            running: false,
            error: serverResult.error
          })
          continue
        }

        // 检查服务状态
        const statusResult = await sshManager.checkServiceRealStatus(serverId, { port, startCommand })
        results.push({
          serviceId: service.id,
          ...statusResult
        })
      }

      return { success: true, data: results }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 数据持久化：读取数据
  ipcMain.handle('data:read', async (event, moduleName, defaultValue = null) => {
    try {
      const data = await dataManager.readData(moduleName, defaultValue)
      return { success: true, data }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 数据持久化：写入数据
  ipcMain.handle('data:write', async (event, moduleName, data) => {
    try {
      return await dataManager.writeData(moduleName, data)
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 数据持久化：删除数据
  ipcMain.handle('data:delete', async (event, moduleName) => {
    try {
      return await dataManager.deleteData(moduleName)
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 数据持久化：检查数据是否存在
  ipcMain.handle('data:exists', async (event, moduleName) => {
    try {
      const exists = await dataManager.existsData(moduleName)
      return { success: true, exists }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 数据持久化：获取所有数据模块列表
  ipcMain.handle('data:list', async () => {
    try {
      const modules = await dataManager.listDataModules()
      return { success: true, data: modules }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 数据持久化：清空所有数据
  ipcMain.handle('data:clearAll', async () => {
    try {
      return await dataManager.clearAllDataAndDirectory()
    } catch (error) {
      return { success: false, error: error.message }
    }
  })


  // 数据持久化：获取数据目录路径
  ipcMain.handle('data:getPath', async () => {
    try {
      const path = dataManager.dataDir
      return { success: true, data: path }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 模型市场：获取模型列表
  ipcMain.handle('modelHub:getModels', async (event, platform, params) => {
    try {
      const { getModels } = await import('../renderer/src/api/modelHub.js')
      const result = await getModels(platform, params)
      return result
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 模型市场：检测下载命令
  ipcMain.handle('modelHub:checkCommand', async (event, serverId, envType, envName, command) => {
    try {
      // 确保服务器已加载到 ssh-manager
      await ensureServerLoaded(serverId)

      const exists = await sshManager.checkDownloadCommand(serverId, envType, envName, command)
      return { success: true, exists }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 模型市场：开始下载
  ipcMain.handle('modelHub:startDownload', async (event, downloadConfig) => {
    try {
      // 确保服务器已加载到 ssh-manager
      await ensureServerLoaded(downloadConfig.serverId)

      const mainWindow = BrowserWindow.fromWebContents(event.sender)
      const result = await sshManager.downloadModel({
        ...downloadConfig,
        mainWindow
      })
      return { success: true, data: result }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 模型市场：取消下载
  ipcMain.handle('modelHub:cancelDownload', async (event, serverId, modelId) => {
    try {
      // 确保服务器已加载到 ssh-manager
      await ensureServerLoaded(serverId)

      const result = await sshManager.cancelDownload(serverId, modelId)
      return result
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 模型测试：测试连接
  ipcMain.handle('modelTest:testConnection', async (event, protocol, serverUrl, apiKey, model) => {
    try {
      let result
      if (protocol === 'openai') {
        result = await modelTestHandler.testOpenAIConnection(serverUrl, apiKey, model)
      } else if (protocol === 'ollama') {
        result = await modelTestHandler.testOllamaConnection(serverUrl, model)
      } else {
        return { success: false, error: '不支持的协议' }
      }
      return result
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 模型测试：获取模型列表
  ipcMain.handle('modelTest:listModels', async (event, protocol, serverUrl, apiKey) => {
    try {
      let result
      if (protocol === 'openai') {
        result = await modelTestHandler.listOpenAIModels(serverUrl, apiKey)
      } else if (protocol === 'ollama') {
        result = await modelTestHandler.listOllamaModels(serverUrl)
      } else {
        return { success: false, error: '不支持的协议' }
      }
      return result
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 模型测试：聊天（流式）
  ipcMain.handle('modelTest:chat', async (event, protocol, serverUrl, apiKey, model, messages, params) => {
    try {
      const mainWindow = BrowserWindow.fromWebContents(event.sender)

      let result
      if (protocol === 'openai') {
        result = await modelTestHandler.chatOpenAI(
          serverUrl,
          apiKey,
          model,
          messages,
          params,
          (chunk) => {
            // 发送流式数据
            if (mainWindow && mainWindow.webContents) {
              mainWindow.webContents.send('modelTest:chunk', { content: chunk })
            }
          }
        )
      } else if (protocol === 'ollama') {
        result = await modelTestHandler.chatOllama(
          serverUrl,
          model,
          messages,
          params,
          (chunk) => {
            // 发送流式数据
            if (mainWindow && mainWindow.webContents) {
              mainWindow.webContents.send('modelTest:chunk', { content: chunk })
            }
          }
        )
      } else {
        return { success: false, error: '不支持的协议' }
      }

      return { success: true, data: result }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 数据源管理：获取 Conda 数据源
  ipcMain.handle('datasource:getConda', async (event, serverId, envType, envName) => {
    try {
      await ensureServerLoaded(serverId)
      const result = await sshManager.getCondaDataSource(serverId, envType, envName)
      return result
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 数据源管理：设置 Conda 数据源
  ipcMain.handle('datasource:setConda', async (event, serverId, channels) => {
    try {
      await ensureServerLoaded(serverId)
      const result = await sshManager.setCondaDataSource(serverId, channels)
      return result
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 数据源管理：获取 Pip 数据源
  ipcMain.handle('datasource:getPip', async (event, serverId, envType, envName) => {
    try {
      await ensureServerLoaded(serverId)
      const result = await sshManager.getPipDataSource(serverId, envType, envName)
      return result
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 数据源管理：设置 Pip 数据源
  ipcMain.handle('datasource:setPip', async (event, serverId, indexUrl, extraIndexUrls) => {
    try {
      await ensureServerLoaded(serverId)
      const result = await sshManager.setPipDataSource(serverId, indexUrl, extraIndexUrls)
      return result
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 数据源管理：恢复默认数据源
  ipcMain.handle('datasource:restoreDefault', async (event, serverId, sourceType) => {
    try {
      await ensureServerLoaded(serverId)
      const result = await sshManager.restoreDefaultDataSource(serverId, sourceType)
      return result
    } catch (error) {
      return { success: false, error: error.message }
    }
  })

  // 数据源管理：测试数据源速度
  ipcMain.handle('datasource:testSpeed', async (event, serverId, url) => {
    try {
      await ensureServerLoaded(serverId)
      const result = await sshManager.testDataSourceSpeed(serverId, url)
      return result
    } catch (error) {
      return { success: false, error: error.message }
    }
  })
  })
}
